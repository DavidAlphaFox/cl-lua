(in-package :cl-user)
(defpackage :cl-lua.convert
  (:use :cl :cl-lua.ast)
  (:import-from
   :alexandria
   :destructuring-ecase)
  (:export :ast-to-list))
(in-package :cl-lua.convert)

(defun ast-to-list (ast)
  (ecase (ast-name ast)
    ((:block)
     `(:block ,(mapcar #'ast-to-list (block-stats ast))))
    ((:return)
     `(:return ,(mapcar #'ast-to-list (return-explist ast))))
    ((:label)
     `(:label ,(label-name ast)))
    ((:goto)
     `(:goto ,(goto-name ast)))
    ((:break)
     '(:break))
    ((:while)
     `(:while
       ,(ast-to-list (while-exp ast))
       ,(ast-to-list (while-body ast))))
    ((:repeat)
     `(:repeat
       ,(ast-to-list (repeat-body ast))
       ,(ast-to-list (repeat-exp ast))))
    ((:if)
     `(:if
       ,(ast-to-list (if-test ast))
       ,(ast-to-list (if-then ast))
       ,(ast-to-list (if-else ast))))
    ((:for)
     `(:for
       ,(for-name ast)
       ,(ast-to-list (for-init ast))
       ,(ast-to-list (for-end ast))
       ,(ast-to-list (for-step ast))
       ,(ast-to-list (for-body ast))))
    ((:generic-for)
     `(:generic-for
       ,(generic-for-namelist ast)
       ,(mapcar #'ast-to-list (generic-for-explist ast))
       ,(ast-to-list (generic-for-body ast))))
    ((:local)
     `(:local
       ,(local-namelist ast)
       ,(if (ast-void-p (local-explist ast))
            (ast-to-list (local-explist ast))
            (mapcar #'ast-to-list (local-explist ast)))))
    ((:local-function)
     `(:local-function
       ,(local-function-name ast)
       ,(local-function-parameters ast)
       ,(ast-to-list (local-function-body ast))))
    ((:assign)
     `(:assign
       ,(mapcar #'ast-to-list (assign-varlist ast))
       ,(mapcar #'ast-to-list (assign-explist ast))))
    ((:var)
     `(:var ,(var-name ast)))
    ((:nil)
     '(:nil))
    ((:false)
     '(:false))
    ((:true)
     '(:true))
    ((:number)
     `(:number ,(number-value ast)))
    ((:string)
     `(:string ,(string-value ast)))
    ((:tableconstructor)
     `(:tableconstructor
       ,(let ((seq (tableconstructor-field-sequence ast)))
          (if (ast-void-p seq)
              (ast-to-list seq)
              (mapcar #'ast-to-list seq)))
       ,(let ((pairs (tableconstructor-field-pairs ast)))
          (if (ast-void-p pairs)
              (ast-to-list pairs)
              (loop :for (k v) :in pairs
                    :collect (list (ast-to-list k)
                                   (ast-to-list v)))))))
    ((:rest)
     '(:rest))
    ((:unary-op)
     `(:unary-op ,(unary-op-name ast)
                 ,(ast-to-list (unary-op-exp ast))))
    ((:binary-op)
     `(:binary-op ,(binary-op-name ast)
                  ,(ast-to-list (binary-op-left ast))
                  ,(ast-to-list (binary-op-right ast))))
    ((:function)
     `(:function ,(function-parameters ast)
                 ,(ast-to-list (function-body ast))))
    ((:index)
     `(:index ,(ast-to-list (index-key ast))
              ,(ast-to-list (index-value ast))))
    ((:call-function)
     `(:call-function ,(ast-to-list (call-function-fun ast))
                      ,(mapcar #'ast-to-list (call-function-args ast))))
    ((:call-method)
     `(:call-method ,(ast-to-list (call-method-prefix ast))
                    ,(call-method-name ast)
                    ,(mapcar #'ast-to-list (call-method-args ast))))
    ((:void)
     '(:void))))
